<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
  <head>
    <title>Frequently Pasted Answers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <style type="text/css">
      html { background-color: #666; font-size: medium; }
      body { margin: 1em 2em; padding: 0; }
      ul.nav { display: block; background-color: #444; margin: 0; padding: 1ex; border-radius: 5px; font-family: "DejaVu Sans", "Trebuchet MS", "Droid Sans", Helvetica, sans-serif; }
      ul.nav li { display: inline-block; border-left: medium solid #AAA; padding: 0; margin: 0; color: white; }
      ul.nav li:first-child { border-left: none; }
      ul.nav li span { margin: 0 1ex; padding: .25ex .5ex; border-radius: 2px; font-weight: normal; font-size: 90%; line-height: 150%; }
      ul.nav li span:hover { background-color: #AAA; color: black; }
      ul.nav li span a:link, ul.nav li span a:visited { color: inherit; text-decoration: none; }
      ul.nav a:link, ul.nav a:visited { border: none; border-radius: 0; margin: 0; padding: 0; }
      ul.nav a:link:hover, ul.nav a:visited:hover { background-color: inherit; color: inherit; }
      h1 { color: #DDD; font-weight: normal; font-size: xx-large; font-style: italic; border-bottom: medium dotted #DDD;
           margin: 1em 0 1ex 0; padding: 0 0 .25ex 0; }
      h2 { color: #DDD; font-size: large;  border-bottom: thin solid #DDD; margin: 2em 0 1em 0; padding: 0 0 1ex 0; display: inline-block; }
      p { color: #DFDFDF; line-height: 150%; margin: 0; padding: 0; }
      div.listing, code { font-family: "DejaVu Sans Mono", Consolas, Courier, monospace; }
      div.listing { white-space: pre; }
      .listing { border-radius: 5px; margin: 1em 0; padding: 1em; background-color: #EEE; line-height: 135%; color: #333; }
      code { margin: 0 .5ex; }
      ul { list-style-type: disc; list-style-position: inside; margin: 1em 0; padding: 1ex; background-color: #888; border-radius: 5px; }
      li { margin: 0; padding: 1ex 0 1ex 1em; }
      a:link, a:visited { text-decoration: none; padding: 0 1ex .5ex 1ex; color: #FFF; border-radius: 2px; }
      a:link:hover, a:visited:hover { background-color: #666; color: #FFF; }
    </style>
  </head>

  <body>
    <ul class="nav">
      <li><span>Perspective</span></li>
      <li><span>Intuition</span></li>
      <li><span>Video</span></li>
      <li><span><a href="#links">Links</a></span></li>
      <li><span><a href="#getline">getline</a></span></li>
      <li><span><a href="#random">random</a></span></li>
      <li><span><a href="#new">new/delete</a></span></li>
      <li><span><a href="#wstring">narrow/wide-char/UTF8</a></span></li>
      <li><span><a href="#erase">remove/erase</a></span></li>
    </ul>

    <h1>To C++ and Beyond</h1>
    <p>The following pieces of code come up again and again and again.</p>


    <h2><a name="getline">Line-based input parsing</a></h2>
    <div class="listing"><![CDATA[#include <fstream>
#include <sstream>
#include <string>

int main()
{
    std::ifstream infile("thefile.txt");
    std::string line;

    while (std::getline(infile, line))
    {
        // process line, e.g.:

        std::istringstream iss(line);
        int n; double d; std::string s;

        if (iss >> n >> d >> s)
        {
            // process tokens
        }
    }
}]]></div>


    <h2><a name="random">Random number generation</a></h2>

    <div class="listing"><![CDATA[#include <random>

typedef std:::mt19937 rng_type;
std::uniform_int_distribution<rng_type::result_type> udist(0, 200);

rng_type rng;

int main()
{
  // seed rng first:
  rng_type::result_type const seedval = get_seed();
  rng.seed(seedval);

  rng_type::result_type random_number = udist(rng);

  return random_number;
}]]></div>


    <h2><a name="new">Replacing operators new and delete</a></h2>

    <div class="listing"><![CDATA[void * operator new(std::size_t n) throw(std::bad_alloc)
{
    void * const p = std::malloc(p);

    if (!p) throw std::bad_alloc();

    return p;
}

void operator delete(void * p) throw()
{
    std::free(p);
}]]></div>

    <p>In C++11, the exception specifications change to &ldquo;none&rdquo; for
    <code>operator new()</code> and to <code>noexcept</code> for <code>operator delete()</code>.</p>

    <p>The typical construction/destruction sequence:</p>

    <div class="listing"><![CDATA[void * addr = ::operator new(sizeof(T)); // allocation

T * p = ::new (addr) T;                  // construction

p->~T();                                 // destruction

::operator delete(addr);                 // deallocation]]></div>


    <h2><a name="wstring">Converting narrow and wide strings</a></h2>

    <div class="listing"><![CDATA[#include <vector>
#include <string>
#include <ostream>
#include <iostream>
#include <cstdlib>
#include <cassert>
#include <clocale>
#include <cerrno>
#include <cwchar>
#include <iconv.h>

const char * LOCALE = NULL;

std::string  get_locale_string(const std::string  & s);
std::string  get_locale_string(const std::wstring & s);
std::wstring get_wstring      (const std::string  & s);
std::wstring get_wstring      (const std::wstring & s);
std::string  get_UTF8         (const std::wstring & s);

inline std::ostream & operator<<(std::ostream & o, const std::wstring & s)
{
  return o << get_locale_string(s);
}
inline std::wostream & operator<<(std::wostream & o, const std::string & s)
{
  return o << get_wstring(s);
}

std::string  get_locale_string(const std::string & s)
{
  return s;
}

std::string get_locale_string(const std::wstring & s)
{
  const wchar_t * cs = s.c_str();
  const std::size_t wn = std::wcsrtombs(NULL, &cs, 0, NULL);

  if (wn == std::size_t(-1))
  {
    std::cout << "Error in wcsrtombs(): " << errno << std::endl;
    return "";
  }

  std::vector<char> buf(wn + 1);
  const std::size_t wn_again = std::wcsrtombs(buf.data(), &cs, wn + 1, NULL);

  if (wn_again == std::size_t(-1))
  {
    std::cout << "Error in wcsrtombs(): " << errno << std::endl;
    return "";
  }

  assert(cs == NULL); // successful conversion

  return std::string(buf.data(), wn);
}

std::wstring get_wstring(const std::wstring & s)
{
  return s;
}

std::wstring get_wstring(const std::string & s)
{
  const char * cs = s.c_str();
  const std::size_t wn = std::mbsrtowcs(NULL, &cs, 0, NULL);

  if (wn == std::size_t(-1))
  {
    std::cout << "Error in mbsrtowcs(): " << errno << std::endl;
    return L"";
  }

  std::vector<wchar_t> buf(wn + 1);
  const std::size_t wn_again = std::mbsrtowcs(buf.data(), &cs, wn + 1, NULL);

  if (wn_again == size_t(-1))
  {
    std::cout << "Error in mbsrtowcs(): " << errno << std::endl;
    return L"";
  }

  assert(cs == NULL); // successful conversion

  return std::wstring(buf.data(), wn);
}

std::string get_UTF8(const std::wstring & s)
{
  iconv_t cd = iconv_open("UTF8", "WCHAR_T");

  if (cd == iconv_t(-1))
  {
    std::cout << "Error while initializing iconv: " << errno << std::endl;
    iconv_close(cd);
    return std::string();
  }

  std::size_t n = s.length() * 6 + 1; // Each character might use up to six CUs.
  const std::size_t norig = n;
  std::size_t m = s.length() * sizeof(std::wstring::value_type);

  std::vector<char> obuf(n);
  char * outbuf = obuf.data();
  const char * inbuf = reinterpret_cast<const char*>(&s[0]);

  const std::size_t ir = iconv(cd, const_cast<char**>(&inbuf), &m, &outbuf, &n);

  if (ir == std::size_t(-1))
  {
    std::cout << "Error while converting with iconv(): " << errno << ":" << EINVAL << ", left " << m
              << ", written " << std::dec << norig - n << " bytes." << std::endl;
    iconv_close(cd);
    return std::string();
  }

  iconv_close(cd);

  return std::string(obuf.data(), norig - n);
}

int main(int argc, char * argv[])
{
  LOCALE = std::setlocale(LC_CTYPE, "");
  std::wstring progname = get_wstring(std::string(argv[0]));
}]]></div>


    <h2><a name="erase">Erasing from a container in a loop</a></h2>

    <div class="listing"><![CDATA[// For an associative container "m" for which "erase()" returns "void":

for (auto it = m.cbegin(); it != m.cend() /* not hoisted */; /* no increment */)
{
    if (delete_condition)
    {
        m.erase(it++);
    }
    else
    {
        ++it;
    }
}


// For a sequence container "v" for which "erase()" returns the next iterator:

for (auto it = v.cbegin(); it != v.cend() /* not hoisted */; /* no increment */)
{
    if (delete_condition)
    {
        it = v.erase(it);
    }
    else
    {
        ++it;
    }
}


// Remove/erase idiom to erase by value from a sequence container "v" (but not "std::list" or "std::forward_list"):

#include <algorithm>

v.erase(std::remove(v.begin(), v.end(), val), v.end());


// Remove/erase from lists:

#include <list>
#include <forward_list>

std::list<T> l1;
std::forward_list<T> l2;

l1.remove(val);
l2.remove(val);]]></div>


    <h2><a name="java">Any Java question</a></h2>
    <p style="font-style: italic;" class="listing">&ldquo;You'll need an abstract factory class. Usually those are good for creating abstract wrappers for concrete types in a generic fashion. Factories are often implemented as singletons, too.&rdquo;</p>

    <h1><a name="links">Links</a></h1>
    <p>Many topics have been asked and answered before time and time again. Here are some good answers,
    for reference and for use as &ldquo;exact duplicate&rdquo;s.</p>

    <ul>
      <li><a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">Parsing HTML with regular expressions</a></li>
    </ul>

    <!-- <div class="listing"><![CDATA[   ]]></div> -->

  </body>
</html>
