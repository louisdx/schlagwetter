<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
  <head>
    <title>Frequently Pasted Answers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <style type="text/css">
      html { background-color: #666; font-size: medium; }
      body { margin: 1em 2em; padding: 0; }
      ul.nav { display: block; background-color: #444; margin: 0; padding: 1ex; border-radius: 5px; font-family: "DejaVu Sans", "Trebuchet MS", "Droid Sans", Helvetica, sans-serif; }
      ul.nav li { display: inline-block; border-left: medium solid #AAA; padding: 0; margin: 0; color: white; }
      ul.nav li:first-child { border-left: none; }
      ul.nav li span { margin: 0 1ex; padding: .25ex .5ex; border-radius: 2px; font-weight: normal; font-size: 90%; line-height: 150%; }
      ul.nav li span:hover { background-color: #AAA; color: black; }
      ul.nav li span a:link, ul.nav li span a:visited { color: inherit; text-decoration: none; }
      ul.nav a:link, ul.nav a:visited { border: none; border-radius: 0; margin: 0; padding: 0; }
      ul.nav a:link:hover, ul.nav a:visited:hover { background-color: inherit; color: inherit; }
      h1 { color: #DDD; font-weight: normal; font-size: xx-large; font-style: italic; border-bottom: medium dotted #DDD;
           margin: 1em 0 1ex 0; padding: 0 0 .25ex 0; }
      h2 { color: #DDD; font-size: large;  border-bottom: thin solid #DDD; margin: 2em 0 1em 0; padding: 0 0 1ex 0; display: inline-block; }
      p { color: #DFDFDF; line-height: 150%; margin: 0; padding: 0; }
      div.listing, code { font-family: "DejaVu Sans Mono", Consolas, Courier, monospace; }
      div.listing { white-space: pre; }
      .listing { border-radius: 5px; margin: 1em 0; padding: 1em; background-color: #EEE; line-height: 135%; color: #333; }
      code { margin: 0 .5ex; }
      ul { list-style-type: disc; list-style-position: inside; margin: 1em 0; padding: 1ex; background-color: #888; border-radius: 5px; }
      li { margin: 0; padding: 1ex 0 1ex 1em; }
      a:link, a:visited { text-decoration: none; padding: 0 1ex .5ex 1ex; color: #FFF; border-radius: 2px; }
      a:link:hover, a:visited:hover { background-color: #666; color: #FFF; }
    </style>
  </head>

  <body>
    <ul class="nav">
      <li><span><a href="#links">Links</a></span></li>
      <li><span><a href="#getline">getline</a></span></li>
      <li><span><a href="#random">random</a></span></li>
      <li><span><a href="#new">new/delete</a></span></li>
      <li><span><a href="#wstring">narrow/wide-char/UTF8</a></span></li>
      <li><span><a href="#erase">remove/erase</a></span></li>
      <li><span><a href="#timing">timing</a></span></li>
    </ul>

    <h1>To C++ and Beyond</h1>
    <p>The following pieces of code come up again and again and again.</p>


    <h2><a name="getline">Line-based input parsing</a></h2>
    <div class="listing">#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main()
{
    std::ifstream infile("thefile.txt");
    std::string line;

    while (std::getline(infile, line))
    {
        // process line, e.g.:

        std::istringstream iss(line);
        int n; double d; std::string s;

        if (iss &gt;&gt; n &gt;&gt; d &gt;&gt; s)
        {
            // process tokens
        }
    }
}</div>


    <h2><a name="random">Random number generation</a></h2>

    <div class="listing">#include &lt;random&gt;

typedef std:::mt19937 rng_type;
std::uniform_int_distribution&lt;rng_type::result_type&gt; udist(0, 200);

rng_type rng;

int main()
{
  // seed rng first:
  rng_type::result_type const seedval = get_seed();
  rng.seed(seedval);

  rng_type::result_type random_number = udist(rng);

  return random_number;
}</div>


    <h2><a name="new">Replacing operators new and delete</a></h2>

    <div class="listing">void * operator new(std::size_t n) throw(std::bad_alloc)
{
    void * const p = std::malloc(p);

    if (!p) throw std::bad_alloc();

    return p;
}

void operator delete(void * p) throw()
{
    std::free(p);
}</div>

    <p>In C++11, the exception specifications change to &ldquo;none&rdquo; for
    <code>operator new()</code> and to <code>noexcept</code> for <code>operator delete()</code>.</p>

    <p>The typical construction/destruction sequence:</p>

    <div class="listing">void * addr = ::operator new(sizeof(T)); // allocation

T * p = ::new (addr) T;                  // construction

p->~T();                                 // destruction

::operator delete(addr);                 // deallocation</div>


    <h2><a name="wstring">Converting narrow and wide strings</a></h2>

    <div class="listing">#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;ostream&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cassert&gt;
#include &lt;clocale&gt;
#include &lt;cerrno&gt;
#include &lt;cwchar&gt;
#include &lt;iconv.h&gt;

const char * LOCALE = NULL;

std::string  get_locale_string(const std::string  &amp; s);
std::string  get_locale_string(const std::wstring &amp; s);
std::wstring get_wstring      (const std::string  &amp; s);
std::wstring get_wstring      (const std::wstring &amp; s);
std::string  get_UTF8         (const std::wstring &amp; s);

inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; o, const std::wstring &amp; s)
{
  return o &lt;&lt; get_locale_string(s);
}
inline std::wostream &amp; operator&lt;&lt;(std::wostream &amp; o, const std::string &amp; s)
{
  return o &lt;&lt; get_wstring(s);
}

std::string  get_locale_string(const std::string &amp; s)
{
  return s;
}

std::string get_locale_string(const std::wstring &amp; s)
{
  const wchar_t * cs = s.c_str();
  const std::size_t wn = std::wcsrtombs(NULL, &amp;cs, 0, NULL);

  if (wn == std::size_t(-1))
  {
    std::cout &lt;&lt; "Error in wcsrtombs(): " &lt;&lt; errno &lt;&lt; std::endl;
    return "";
  }

  std::vector&lt;char&gt; buf(wn + 1);
  const std::size_t wn_again = std::wcsrtombs(buf.data(), &amp;cs, wn + 1, NULL);

  if (wn_again == std::size_t(-1))
  {
    std::cout &lt;&lt; "Error in wcsrtombs(): " &lt;&lt; errno &lt;&lt; std::endl;
    return "";
  }

  assert(cs == NULL); // successful conversion

  return std::string(buf.data(), wn);
}

std::wstring get_wstring(const std::wstring &amp; s)
{
  return s;
}

std::wstring get_wstring(const std::string &amp; s)
{
  const char * cs = s.c_str();
  const std::size_t wn = std::mbsrtowcs(NULL, &amp;cs, 0, NULL);

  if (wn == std::size_t(-1))
  {
    std::cout &lt;&lt; "Error in mbsrtowcs(): " &lt;&lt; errno &lt;&lt; std::endl;
    return L"";
  }

  std::vector&lt;wchar_t&gt; buf(wn + 1);
  const std::size_t wn_again = std::mbsrtowcs(buf.data(), &amp;cs, wn + 1, NULL);

  if (wn_again == size_t(-1))
  {
    std::cout &lt;&lt; "Error in mbsrtowcs(): " &lt;&lt; errno &lt;&lt; std::endl;
    return L"";
  }

  assert(cs == NULL); // successful conversion

  return std::wstring(buf.data(), wn);
}

std::string get_UTF8(const std::wstring &amp; s)
{
  iconv_t cd = iconv_open("UTF8", "WCHAR_T");

  if (cd == iconv_t(-1))
  {
    std::cout &lt;&lt; "Error while initializing iconv: " &lt;&lt; errno &lt;&lt; std::endl;
    iconv_close(cd);
    return std::string();
  }

  std::size_t n = s.length() * 6 + 1; // Each character might use up to six CUs.
  const std::size_t norig = n;
  std::size_t m = s.length() * sizeof(std::wstring::value_type);

  std::vector&lt;char&gt; obuf(n);
  char * outbuf = obuf.data();
  const char * inbuf = reinterpret_cast&lt;const char*&gt;(&amp;s[0]);

  const std::size_t ir = iconv(cd, const_cast&lt;char**&gt;(&amp;inbuf), &amp;m, &amp;outbuf, &amp;n);

  if (ir == std::size_t(-1))
  {
    std::cout &lt;&lt; "Error while converting with iconv(): " &lt;&lt; errno &lt;&lt; ":" &lt;&lt; EINVAL &lt;&lt; ", left " &lt;&lt; m
              &lt;&lt; ", written " &lt;&lt; std::dec &lt;&lt; norig - n &lt;&lt; " bytes." &lt;&lt; std::endl;
    iconv_close(cd);
    return std::string();
  }

  iconv_close(cd);

  return std::string(obuf.data(), norig - n);
}

int main(int argc, char * argv[])
{
  LOCALE = std::setlocale(LC_CTYPE, "");
  std::wstring progname = get_wstring(std::string(argv[0]));
}</div>


    <h2><a name="erase">Erasing from a container in a loop</a></h2>

    <div class="listing">// For an associative container "m" for which "erase()" returns "void":

for (auto it = m.cbegin(); it != m.cend() /* not hoisted */; /* no increment */)
{
    if (delete_condition)
    {
        m.erase(it++);
    }
    else
    {
        ++it;
    }
}


// For a sequence container "v" for which "erase()" returns the next iterator:

for (auto it = v.cbegin(); it != v.cend() /* not hoisted */; /* no increment */)
{
    if (delete_condition)
    {
        it = v.erase(it);
    }
    else
    {
        ++it;
    }
}


// Remove/erase idiom to erase by value from a sequence container "v" (but not "std::list" or "std::forward_list"):

#include &lt;algorithm&gt;

v.erase(std::remove(v.begin(), v.end(), val), v.end());


// Remove/erase from lists:

#include &lt;list&gt;
#include &lt;forward_list&gt;

std::list&lt;T&gt; l1;
std::forward_list&lt;T&gt; l2;

l1.remove(val);
l2.remove(val);</div>


    <h2><a name="timing">Timing</a></h2>

    <div class="listing">#include &lt;ctime&gt;

#define CLOCK_TICK(acc, ctr)  ctr = std::clock()
#define CLOCK_TOCK(acc, ctr)  acc += (std::clock() - ctr)
#define CLOCK_RESET(acc)      acc = 0
#define CLOCK_REPORT(acc)     (1000. * double(acc) / double(CLOCKS_PER_SEC))

static clock_t tacc, tctr;

int main()
{
    CLOCK_RESET(tacc);

    CLOCK_TICK(tacc, tctr);
    some_function();
    CLOCK_TOCK(tacc, tctr);

    // time taken: CLOCK_REPORT(tacc) milliseconds.
}</div>


    <h2><a name="java">Any Java question</a></h2>
    <p style="font-style: italic;" class="listing">&ldquo;You'll need an abstract factory class. Usually those are good for creating abstract wrappers for concrete types in a generic fashion. Factories are often implemented as singletons, too.&rdquo;</p>

    <h1><a name="links">Links</a></h1>
    <p>Many topics have been asked and answered before time and time again. Here are some good answers,
    for reference and for use as &ldquo;exact duplicate&rdquo;s.</p>

    <ul>
      <li><a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">Parsing HTML with regular expressions</a></li>
    </ul>

  </body>
</html>
