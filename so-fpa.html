<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
  <head>
    <title>Frequently Pasted Answers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <style type="text/css">
      html { background-color: #666; font-size: medium; }
      body { margin: 1em 2em; padding: 0; }
      ul.nav { display: block; background-color: #444; margin: 0; padding: 1ex; border-radius: 5px; font-family: "DejaVu Sans", "Trebuchet MS", "Droid Sans", Helvetica, sans-serif; }
      ul.nav li { display: inline-block; border-left: medium solid #AAA; padding: 0; margin: 0; color: white; }
      ul.nav li:first-child { border-left: none; }
      ul.nav li span { margin: 0 1ex; padding: .25ex .5ex; border-radius: 2px; font-weight: normal; font-size: 90%; line-height: 150%; }
      ul.nav li span:hover { background-color: #AAA; color: black; }
      ul.nav li span a:link, ul.nav li span a:visited { color: inherit; text-decoration: none; }
      ul.nav a:link, ul.nav a:visited { border: none; border-radius: 0; margin: 0; padding: 0; }
      ul.nav a:link:hover, ul.nav a:visited:hover { background-color: inherit; color: inherit; }
      h1 { color: #DDD; font-weight: normal; font-size: xx-large; font-style: italic; border-bottom: medium dotted #DDD;
           margin: 1em 0 1ex 0; padding: 0 0 .25ex 0; }
      h2 { color: #DDD; font-size: large;  border-bottom: thin solid #DDD; margin: 2em 0 1em 0; padding: 0 0 1ex 0; display: inline-block; }
      p { color: #DFDFDF; line-height: 150%; margin: 0; padding: 0; }
      div.listing, code { font-family: "DejaVu Sans Mono", Consolas, Courier, monospace; }
      div.listing { white-space: pre; }
      .listing { border-radius: 5px; margin: 1em 0; padding: 1em; background-color: #EEE; line-height: 135%; color: #333; }
      code { margin: 0 .5ex; }
      ul { list-style-type: disc; list-style-position: inside; margin: 1em 0; padding: 1ex; background-color: #888; border-radius: 5px; }
      li { margin: 0; padding: 1ex 0 1ex 1em; }
      a:link, a:visited { text-decoration: none; padding: 0 1ex .5ex 1ex; color: #FFF; border-radius: 2px; }
      a:link:hover, a:visited:hover { background-color: #666; color: #FFF; }
    </style>
  </head>

  <body>
    <ul class="nav">
      <li><span><a href="#links">Links</a></span></li>
      <li><span><a href="#getline">getline</a></span></li>
      <li><span><a href="#random">random</a></span></li>
      <li><span><a href="#new">new/delete</a></span></li>
      <li><span><a href="#wstring">narrow/wide-char/UTF8</a></span></li>
      <li><span><a href="#erase">remove/erase</a></span></li>
      <li><span><a href="#timing">timing</a></span></li>
      <li><span><a href="#typeerasure">type erasure</a></span></li>
      <li><span><a href="#hash">combining hashes</a></span></li>
    </ul>

    <h1>To C++ and Beyond</h1>
    <p>The following pieces of code come up again and again and again.</p>


    <h2><a name="getline">Line-based input parsing</a></h2>
    <div class="listing">#include &lt;fstream&gt;   // for std::ifstream
#include &lt;sstream&gt;   // for std::istringstream
#include &lt;string&gt;    // for std::string and std::getline

int main()
{
    std::ifstream infile("thefile.txt");
    std::string line;

    while (std::getline(infile, line))
    {
        // process line, e.g.:

        std::istringstream iss(line);
        int n; double d; std::string s;

        if (iss &gt;&gt; n &gt;&gt; d &gt;&gt; s)
        {
            // process tokens
        }
    }
}</div>


    <h2><a name="random">Random number generation</a></h2>

    <div class="listing">#include &lt;random&gt;

typedef std::mt19937 rng_type;
std::uniform_int_distribution&lt;rng_type::result_type&gt; udist(0, 200);

rng_type rng;

int main()
{
  // seed rng first:
  rng_type::result_type const seedval = get_seed();
  rng.seed(seedval);

  rng_type::result_type random_number = udist(rng);

  return random_number;
}</div>


    <h2><a name="new">Replacing operators new and delete</a></h2>

    <div class="listing">void * operator new(std::size_t n) throw(std::bad_alloc)
{
    void * const p = std::malloc(p);

    if (!p) throw std::bad_alloc();

    return p;
}

void operator delete(void * p) throw()
{
    std::free(p);
}</div>

    <p>In C++11, the exception specifications change to &ldquo;none&rdquo; for
    <code>operator new()</code> and to <code>noexcept</code> for <code>operator delete()</code>.</p>

    <p>The typical construction/destruction sequence:</p>

    <div class="listing">void * addr = ::operator new(sizeof(T)); // allocation

T * p = ::new (addr) T;                  // construction

p->~T();                                 // destruction

::operator delete(addr);                 // deallocation</div>


    <h2><a name="wstring">Converting narrow and wide strings</a></h2>

    <div class="listing">#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;ostream&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cassert&gt;
#include &lt;clocale&gt;
#include &lt;cerrno&gt;
#include &lt;cwchar&gt;
#include &lt;iconv.h&gt;

const char * LOCALE = NULL;

std::string  get_locale_string(const std::string  &amp; s);
std::string  get_locale_string(const std::wstring &amp; s);
std::wstring get_wstring      (const std::string  &amp; s);
std::wstring get_wstring      (const std::wstring &amp; s);
std::string  get_UTF8         (const std::wstring &amp; s);

inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; o, const std::wstring &amp; s)
{
    return o &lt;&lt; get_locale_string(s);
}

inline std::wostream &amp; operator&lt;&lt;(std::wostream &amp; o, const std::string &amp; s)
{
    return o &lt;&lt; get_wstring(s);
}

std::string  get_locale_string(const std::string &amp; s)
{
    return s;
}

std::string get_locale_string(const std::wstring &amp; s)
{
    const wchar_t * cs = s.c_str();
    const std::size_t wn = std::wcsrtombs(NULL, &amp;cs, 0, NULL);

    if (wn == std::size_t(-1))
    {
        std::cout &lt;&lt; "Error in wcsrtombs(): " &lt;&lt; errno &lt;&lt; std::endl;
        return std::string();
    }

    std::vector&lt;char&gt; buf(wn + 1);
    const std::size_t wn_again = std::wcsrtombs(buf.data(), &amp;cs, wn + 1, NULL);

    if (wn_again == std::size_t(-1))
    {
        std::cout &lt;&lt; "Error in wcsrtombs(): " &lt;&lt; errno &lt;&lt; std::endl;
        return std::string();
    }

    assert(cs == NULL); // successful conversion

    return std::string(buf.data(), wn);
}

std::wstring get_wstring(const std::wstring &amp; s)
{
    return s;
}

std::wstring get_wstring(const std::string &amp; s)
{
    const char * cs = s.c_str();
    const std::size_t wn = std::mbsrtowcs(NULL, &amp;cs, 0, NULL);

    if (wn == std::size_t(-1))
    {
        std::cout &lt;&lt; "Error in mbsrtowcs(): " &lt;&lt; errno &lt;&lt; std::endl;
        return std::wstring();
    }

    std::vector&lt;wchar_t&gt; buf(wn + 1);
    const std::size_t wn_again = std::mbsrtowcs(buf.data(), &amp;cs, wn + 1, NULL);

    if (wn_again == size_t(-1))
    {
        std::cout &lt;&lt; "Error in mbsrtowcs(): " &lt;&lt; errno &lt;&lt; std::endl;
        return std::wstring();
    }

    assert(cs == NULL); // successful conversion

    return std::wstring(buf.data(), wn);
}

std::string get_UTF8(const std::wstring &amp; s)
{
    iconv_t cd = iconv_open("UTF8", "WCHAR_T");

    if (cd == iconv_t(-1))
    {
        std::cout &lt;&lt; "Error while initializing iconv: " &lt;&lt; errno &lt;&lt; std::endl;
        iconv_close(cd);
        return std::string();
    }

    std::size_t n = s.length() * 6 + 1; // Each character might use up to six CUs.
    const std::size_t norig = n;
    std::size_t m = s.length() * sizeof(std::wstring::value_type);

    std::vector&lt;char&gt; obuf(n);
    char * outbuf = obuf.data();
    const char * inbuf = reinterpret_cast&lt;const char*&gt;(&amp;s[0]);

    const std::size_t ir = iconv(cd, const_cast&lt;char**&gt;(&amp;inbuf), &amp;m, &amp;outbuf, &amp;n);

    if (ir == std::size_t(-1))
    {
        std::cout &lt;&lt; "Error while converting with iconv(): " &lt;&lt; errno &lt;&lt; ":" &lt;&lt; EINVAL &lt;&lt; ", left " &lt;&lt; m
                  &lt;&lt; ", written " &lt;&lt; std::dec &lt;&lt; norig - n &lt;&lt; " bytes." &lt;&lt; std::endl;
        iconv_close(cd);
        return std::string();
    }

    iconv_close(cd);

    return std::string(obuf.data(), norig - n);
}

int main(int argc, char * argv[])
{
    LOCALE = std::setlocale(LC_CTYPE, "");
    std::wstring progname = get_wstring(std::string(argv[0]));
}</div>


    <h2><a name="erase">Erasing from a container in a loop</a></h2>

    <div class="listing">// For an associative container "m" for which "erase()" returns "void":

for (auto it = m.cbegin(); it != m.cend() /* not hoisted */; /* no increment */)
{
    if (delete_condition)
    {
        m.erase(it++);
    }
    else
    {
        ++it;
    }
}


// For a sequence container "v" for which "erase()" returns the next iterator:

for (auto it = v.cbegin(); it != v.cend() /* not hoisted */; /* no increment */)
{
    if (delete_condition)
    {
        it = v.erase(it);
    }
    else
    {
        ++it;
    }
}


// Remove/erase idiom to erase by value from a sequence container "v" (but not "std::list" or "std::forward_list"):

#include &lt;algorithm&gt;

v.erase(std::remove(v.begin(), v.end(), val), v.end());


// Remove/erase from lists:

#include &lt;list&gt;
#include &lt;forward_list&gt;

std::list&lt;T&gt; l1;
std::forward_list&lt;T&gt; l2;

l1.remove(val);
l2.remove(val);</div>


    <h2><a name="timing">Timing</a></h2>

    <div class="listing">#include &lt;ctime&gt;

#define CLOCK_TICK(acc, ctr)  ctr = std::clock()
#define CLOCK_TOCK(acc, ctr)  acc += (std::clock() - ctr)
#define CLOCK_RESET(acc)      acc = 0
#define CLOCK_REPORT(acc)     (1000. * double(acc) / double(CLOCKS_PER_SEC))

static clock_t tacc, tctr;

int main()
{
    CLOCK_RESET(tacc);

    CLOCK_TICK(tacc, tctr);
    some_function();
    CLOCK_TOCK(tacc, tctr);

    // time taken: CLOCK_REPORT(tacc) milliseconds.
}</div>

    <p>With the <code>&lt;chrono&gt;</code> features of C++11, we can build a better timer:</p>

    <div class="listing">#include &lt;chrono&gt;
#include &lt;ctime&gt;

template &lt;typename T&gt; class basic_stopwatch
{
    typedef T clock;
    typename clock::time_point p;
    typename clock::duration   d;
 
public:
    void tick()  { p  = clock::now();            }
    void tock()  { d += clock::now() - p;        }
    void reset() { d  = clock::duration::zero(); }

    template &lt;typename S&gt; unsigned long long int report() const
    {
        return std::chrono::duration_cast&lt;S&gt;(d).count();
    }

    unsigned long long int report_ms() const
    {
        return report&lt;std::chrono::milliseconds&gt;
    }

    basic_stopwatch() : p(), d() { }
};

struct c_clock
{
    typedef std::clock_t time_point;
    typedef std::clock_t duration;
    static time_point now() { return std::clock(); }
};

template &lt;&gt; unsigned long long int basic_stopwatch&lt;c_clock&gt;::report_ms() const
{
  return 1000. * double(d) / double(CLOCKS_PER_SEC);
}

typedef basic_stopwatch&lt;std::chrono::high_resolution_clock&gt; stopwatch;
typedef basic_stopwatch&lt;c_clock&gt; cstopwatch;</div>

    <p>Usage:</p>

<div class="listing">#include &lt;iostream&gt;

int main()
{
    stopwatch sw;

    sw.tick();
    some_function();
    sw.tock();

    // time taken: sw.report_ms() milliseconds
}</div>


    <h2><a name="typeerasure">Type erasure</a></h2>

    <p>The following framework defines a public class <code>TEClass</code> which
    has a templated family of constructors that accept arguments whose type will
    be erased. All accepted argument types must expose some common interface as
    required by the private virtual placeholder base class <code>TEImplBase</code>.
    The crucial feature of type erasure is that there is only one single public
    type (namely <code>TEClass</code>), but it can be constructed with an arbitrarily
    typed value. The type of the constructor argument is &ldquo;forgotten&rdquo; by the
    class.</p>

    <div class="listing">#include &lt;memory&gt;
#include &lt;type_traits&gt;

class TEClass
{
    struct TEImplBase
    {
        virtual ~TEImplBase() { }
        virtual void do_something() = 0;
    };

    template &lt;typename&gt; struct TEImpl; // implement!

    std::unique_ptr&lt;TEImplBase&gt; impl;

public:

    template &lt;typename T&gt;
    TEClass(T && x)
    : impl(new TEImpl&lt;typename std::decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(x)))
    {
    }

    void do_something()
    {
        impl-&gt;do_something();
    }

private:

    /* A minimal implementation example:
     *
     * The concrete implementation must derive from TEImplBase, provide a
     * matching constructor, and implementations of the TEImplBase interface.
     */
    template &lt;typename T&gt;
    struct TEImpl : TEImplBase
    {
        TEImpl(T) { }
        void do_something() { }
    };
};</div>


    <h2><a name="hash">Combining hashes</a></h2>

    <p>The standard library provides specializations of <code>std::hash&lt;T&gt;</code> for
    the fundamental types and for strings, but it does not include a mechanism for defining
    a composite hash in terms of hashable components. Boost provides this facility in the
    form of <code>hash_combine()</code>. This is easily replicated, and the following code
    demonstrates how to use it to hash pairs, arrays and tuples of hashable objects.</p>

    <div class="listing">#include &lt;array&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;

template &lt;class T&gt;
inline void hash_combine(std::size_t &amp; seed, const T &amp; v)
{
    std::hash&lt;T&gt; hasher;
    seed ^= hasher(v) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);
}

template &lt;class Tuple, std::size_t Index = std::tuple_size&lt;Tuple&gt;::value - 1&gt;
struct tuple_hash_impl
{
    static inline void apply(std::size_t &amp; seed, Tuple const &amp; tuple)
    {
        tuple_hash_impl&lt;Tuple, Index - 1&gt;::apply(seed, tuple);
        hash_combine(seed, std::get&lt;Index&gt;(tuple));
    }
};

template &lt;class Tuple&gt;
struct tuple_hash_impl&lt;Tuple, 0&gt;
{
    static inline void apply(std::size_t &amp; seed, Tuple const &amp; tuple)
    {
        hash_combine(seed, std::get&lt;0&gt;(tuple));
    }
};

namespace std
{
    template&lt;typename S, typename T&gt; struct hash&lt;pair&lt;S, T&gt;&gt;
    {
        inline size_t operator()(const pair&lt;S, T&gt; &amp; v) const
        {
            size_t seed = 0;
            ::hash_combine(seed, v.first);
            ::hash_combine(seed, v.second);
            return seed;
        }
    };

    template&lt;typename T, size_t N&gt; struct hash&lt;array&lt;T, N&gt;&gt;
    {
        inline size_t operator()(const array&lt;T, N&gt; &amp; a) const
        {
            size_t seed = 0;
            for (size_t i = 0; i != N; ++i)
            {
                ::hash_combine(seed, a[i]);
            }
            return seed;
        }
    };

    template&lt;typename ...Args&gt; struct hash&lt;tuple&lt;Args...&gt;&gt;
    {
        inline size_t operator()(const tuple&lt;Args...&gt; &amp; v) const
        {
            size_t seed = 0;
            tuple_hash_impl&lt;tuple&lt;Args...&gt;&gt;::apply(seed, v);
            return seed;
        }
    };
}</div>

    <p>Usage example:</p>

    <div class="listing">#include &lt;unordered_set&gt;

typedef std::pair&lt;int, int&gt;       P;
typedef std::tuple&lt;int, int, int&gt; T;
typedef std::array&lt;int, 4&gt;        A;

int main()
{
  std::unordered_set&lt;P&gt; s1 { {1,1} };
  std::unordered_set&lt;T&gt; s2 { T{2,2,2} };
  std::unordered_set&lt;A&gt; s3 { {{3,3,3,3}} };
}</div>


    <h2><a name="java">Any Java question</a></h2>
    <p style="font-style: italic;" class="listing">&ldquo;You'll need an abstract factory class. Usually those are good for creating abstract wrappers for concrete types in a generic fashion. Factories are often implemented as singletons, too.&rdquo;</p>

    <h1><a name="links">Links</a></h1>
    <p>Many topics have been asked and answered before time and time again. Here are some good answers,
    for reference and for use as &ldquo;exact duplicate&rdquo;s.</p>

    <ul>
      <li><a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">Parsing HTML with regular expressions</a></li>
      <li><a href="http://louisdx.github.com/cxx-prettyprint/">A C++ container pretty-printer</a></li>
    </ul>

  </body>
</html>
